import discord
from discord.ext import commands, tasks
from collections import defaultdict
import re  # ì •ê·œ í‘œí˜„ì‹ì„ ì‚¬ìš©í•˜ì—¬ í•„í„°ë§í•  ìˆ˜ ìˆë„ë¡
import aiohttp  # ë¹„ë™ê¸° HTTP ìš”ì²­
from discord.utils import utcnow
from datetime import timedelta, datetime, timezone
import requests
import asyncio
import os
import logging
import random
import yt_dlp as youtube_dl
import json
from bs4 import BeautifulSoup
import openai

# ë´‡ ì ‘ë‘ì–´ ì„¤ì •
intents = discord.Intents.default()
intents = discord.Intents.all()
intents.message_content = True  # ë©”ì‹œì§€ ë‚´ìš© ì ‘ê·¼ì„ í—ˆìš©
intents.messages = True
intents.members = True
intents.guilds = True

bot = commands.Bot(command_prefix="?", intents=intents)

VALORANT_PATCH_URL = 'https://playvalorant.com/en-us/news/game-updates/'
FISCH_GAME_URL = 'https://www.roblox.com/games/16732694052/Fisch'  # Replace with actual game ID

# ìµœëŒ€ ê²½ê³  íšŸìˆ˜ ì„¤ì • (ì˜ˆ: 3íšŒ ê²½ê³  ì‹œ ì¡°ì¹˜)
WARNING_LIMIT = 2

# ê²½ê³  ê¸°ë¡ ì €ì¥
warnings = defaultdict(int)

WARNINGS_FILE = "warnings.json"  # ê²½ê³  ê¸°ë¡ íŒŒì¼

# ğŸ”¹ JSONì—ì„œ ê²½ê³  ê¸°ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
def load_warnings():
    if os.path.exists(WARNINGS_FILE):
        with open(WARNINGS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return {}

# ğŸ”¹ JSONì— ê²½ê³  ê¸°ë¡ ì €ì¥
def save_warnings(warnings):
    with open(WARNINGS_FILE, "w", encoding="utf-8") as f:
        json.dump(warnings, f, indent=4, ensure_ascii=False)

warnings = load_warnings()

LOG_FILE = "log_channel.json"  # ë¡œê·¸ ì±„ë„ íŒŒì¼

# ë¡œê·¸ í´ë” ë° íŒŒì¼ ê²½ë¡œ ì„¤ì •
LOG_FOLDER = 'logs'  # ë¡œê·¸ íŒŒì¼ì„ ì €ì¥í•  í´ë”
if not os.path.exists(LOG_FOLDER):
    os.makedirs(LOG_FOLDER)  # í´ë”ê°€ ì—†ìœ¼ë©´ ìƒì„±

# ë‚ ì§œë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•œ ë¡œê·¸ íŒŒì¼ ì´ë¦„
LOG_FILE = os.path.join(LOG_FOLDER, f"activity_log_{datetime.now().strftime('%Y-%m-%d')}.json")

# ë¡œê·¸ë¥¼ íŒŒì¼ì— ì €ì¥í•˜ëŠ” í•¨ìˆ˜
def save_log_to_file(message):
    # ì´ë¯¸ íŒŒì¼ì´ ì¡´ì¬í•˜ë©´ ì½ê¸°, ì—†ìœ¼ë©´ ìƒˆë¡œìš´ ë¦¬ìŠ¤íŠ¸ ìƒì„±
    if os.path.exists(LOG_FILE):
        with open(LOG_FILE, 'r', encoding='utf-8') as file:
            logs = json.load(file)
    else:
        logs = []

    # ìƒˆ ë©”ì‹œì§€ë¥¼ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
    logs.append(message)

    # ë¡œê·¸ë¥¼ JSON í˜•ì‹ìœ¼ë¡œ ì €ì¥
    with open(LOG_FILE, 'w', encoding='utf-8') as file:
        json.dump(logs, file, ensure_ascii=False, indent=4)

MUTE_DURATION = 604800  # ë®¤íŠ¸ ì‹œê°„ (ì´ˆ) - í•„ìš” ì‹œ ë³€ê²½ ê°€ëŠ¥

# ê´€ë¦¬ì ì±„ë„ ID ì„¤ì • (ê´€ë¦¬ìê°€ ë°›ì„ DM ì±„ë„ ID)
admin_id = 1321813368817848382

# ê·œì¹™ ìœ„ë°˜ì„ ê°ì§€í•˜ëŠ” ê°„ë‹¨í•œ í•„í„° ì˜ˆì‹œ
BAD_WORDS = ["ì‹œë°œ", "ê°œì‹œë°œ", "ì”¨ë°œ", "ê°œì”¨ë°œ", "ë¯¸ì¹œ", "ë¯¸ì¹œë†ˆ", "ë¯¸ì¹œë…„", "ë²•ê·œ", "ê²Œì´", "ë˜ë¼ì´", "ë ˆì¦ˆë¹„ì–¸", "ë ˆì¦ˆ", "ã……ã…‚", "ã…ã…Š", "ã…ã…Šã„´", "ã…ã…Šã„´", "ã„±ã…‡", "ã„¹ã…ˆ", "ã„¹ã…ˆã…‚ã…‡", "ã„¸ã„¹ã…‡", "ã…†ã…‚", "tq", "tlqkf", "ã…„", "ã…‚ã……", "qt", "ê°œìƒˆë¼", "ã……ã„±ã…†", "ã„³ã„²", "ìƒ‰ìŠ¤", "ì„¹ìŠ¤", "ã……ã……", "ã…ˆã„²", "ã……ã…‚", "/ã…£ ë°œ", "ì”¨ë°œ", "ì”¨ë°”", "ì‹œ ë°œ", "ê°œì„¸ë¼", "18ë…„", "18ë†ˆ", "18ìƒˆë¼", "ã„±ã…ã……ã…ã„²l", "ã„±ã…ã…ˆã…", "ê°€ìŠ´ë§Œì ¸", "ê°€ìŠ´ë¹¨ì•„", "ê°€ìŠ´ë¹¨ì–´", "ê°€ìŠ´ì¡°ë¬¼ë½", "ê°€ìŠ´ì£¼ë¬¼ëŸ­", "ê°€ìŠ´ìª¼ë¬¼ë”±", "ê°€ìŠ´ìª¼ë¬¼ë½", "ê°€ìŠ´í•§ì•„", "ê°€ìŠ´í•§ì–´", "ê°•ê°„", "ê°œê°€íŠ¼ë…„", "ê°œê°€íŠ¼ë‡¬", "ê°œê°™ì€ë…„", "ê°œê±¸ë ˆ", "ê°œê³ ì¹˜", "ê°œë„ˆë¯¸", "ê°œë„˜", "ê°œë…„", "ê°œë†ˆ", "ê°œëŠ ", "ê°œë˜¥", 'ê°œë–µ', 'ê°œë–¡', 'ê°œë¼ìŠ¥', 'ê°œë³´ì§€', 'ê°œë¶€ë‹¬', 'ê°œë¶€ë„', 'ê°œë¶ˆë„', 'ê°œë¶•ì•Œ', 'ê°œìƒˆ', 'ê°œì„¸', 'ê°œì“°ë˜ê¸°', 'ê°œì“°ë ˆê¸°', 'ê°œì”ë…„', 'ê°œì”ë¸”', 'ê°œì”ìì§€', 'ê°œì”¨ë°œ', 'ê°œì”¨ë¸”', 'ê°œìì‹', 'ê°œìì§€', 'ê°œì¡ë…„', 'ê°œì “ê°€íŠ¼ë„˜', 'ê°œì¢†', 'ê°œì§€ë„', 'ê°œí›„ë¼ë…„', 'ê°œí›„ë¼ë“¤ë†ˆ', 'ê°œí›„ë¼ìƒˆë¼', 'ê±”ì¡ë…„', 'ê±°ì‹œê¸°', 'ê±¸ë˜ë…„', 'ê±¸ë ˆê°™ì€ë…„', 'ê±¸ë ˆë…„', 'ê±¸ë ˆí•€ë…„', 'ê²Œë¶€ëŸ´', 'ê²Œì„¸ë¼', 'ê²Œì´', 'ê²Œìƒˆë¼', 'ê²ŒëŠ ', 'ê²Œìì‹', 'ê²Œì§€ë„ë†ˆ', 'ê³ í™˜', 'ê³µì§€ì‚¬í•­', 'ê·€ë‘', 'ê¹¨ìŒ”ë¼', 'ë‚œìë§ˆì…”', 'ë‚œìë¨¹ì–´', 'ë‚œìí•§ì•„', 'ë‚´êº¼ë¹¨ì•„', 'ë‚´êº¼í•§ì•„', 'ë‚´ë²„ì§€', 'ë‚´ìì§€', 'ë‚´ì ì§€', 'ë‚´ì¡°ì§€', 'ë„ˆê±°ì• ë¹„', 'ë…¸ì˜´', 'ëˆ„ë‚˜ê°•ê°„', 'ë‹ˆê¸°ë¯¸', 'ë‹ˆë¿¡', 'ë‹ˆë½•', 'ë‹ˆì”¨ë¸Œë„', 'ë‹ˆì•„ë²”', 'ë‹ˆì•„ë¹„', 'ë‹ˆì• ë¯¸', 'ë‹ˆì• ë·”', 'ë‹ˆì• ë¹„', 'ë‹ˆí• ì• ë¹„', 'ë‹ê¸°ë¯¸', 'ë‹Œê¸°ë¯¸', 'ë‹ˆë¯¸', 'ë‹³ì€ë…„', 'ëœì€ìƒˆë¼', 'ëˆìƒˆë¼', 'ëŒìœ¼ë…„', 'ëŒì€ë„˜', 'ëŒì€ìƒˆë¼', 'ë™ìƒê°•ê°„', 'ë™ì„±ì• ì', 'ë”¸ë”¸ì´', 'ë˜¥êµ¬ë…', 'ë˜¥ê¾¸ë‡½', 'ë˜¥êµ¬ë‡½', 'ë˜¥', 'ë ë°œë‡¬', 'ë íŒ”', 'ë í„', 'ë í’€', 'ë ë²Œ', 'ë ë²¨', 'ë ë¹Œ', 'ë§ˆìŠ¤í„°', 'ë§‰ê°„ë…„', 'ë§‰ëŒ€ì‘¤ì…”ì¤˜', 'ë§‰ëŒ€í•§ì•„ì¤˜', 'ë§›ê°„ë…„', 'ë§›ì—†ëŠ”ë…„', 'ë§›ì´ê°„ë…„', 'ë©œë¦¬ìŠ¤', 'ë¯¸ì¹œêµ¬ë…•', 'ë¯¸ì¹œêµ¬ë©', 'ë¯¸ì¹œë„˜', 'ë¯¸ì¹œë…„', 'ë¯¸ì¹œë†ˆ', 'ë¯¸ì¹œëˆ”', 'ë¯¸ì¹œìƒˆë¼', 'ë¯¸ì¹œì‡„ë¦¬', 'ë¯¸ì¹œì‡ ë¦¬', 'ë¯¸ì¹œì‰ì´', 'ë¯¸ì¹œì”¨ë¶€ë„', 'ë¯¸íŠ„', 'ë¯¸í‹°ë„˜', 'ë¯¸í‹´', 'ë¯¸í‹´ë„˜', 'ë¯¸í‹´ë…„', 'ë¯¸í‹´ë†ˆ', 'ë¯¸í‹´ê²ƒ', 'ë°±ë³´ì§€', 'ë²„ë”°ë¦¬ìì§€', 'ë²„ì§€êµ¬ë…•', 'ë²„ì§€êµ¬ë©', 'ë²„ì§€ëƒ„ìƒˆ', 'ë²„ì§€ë”°ë¨¹ê¸°', 'ë²„ì§€ëš«ì–´', 'ë²„ì§€ëœ¨ë”', 'ë²„ì§€ë¬¼ë§ˆì…”', 'ë²„ì§€ë²Œë ¤', 'ë²„ì§€ë²Œë£Œ', 'ë²„ì§€ë¹¨ì•„', 'ë²„ì§€ë¹¨ì–´', 'ë²„ì§€ì°ì–´', 'ë²„ì§€ì‘¤ì…”', 'ë²„ì§€í„¸', 'ë²„ì§€í•§ì•„', 'ë²„ì§“ë¬¼', 'ë²„ì§“ë¬¼ë§ˆì…”', 'ë²Œì°½ê°™ì€ë…„', 'ë²µì‹ ', 'ë³‘ë‹¥', 'ë³‘ë”±', 'ë³‘ì‹ ', 'ë³´ì¥', 'ë³´ì§€', 'ë³´ì§€í•§ì–´', 'ë³´ì§“ë¬¼', 'ë³´ì§“ë¬¼ë§ˆì…”', 'ë´‰ì•Œ', 'ë¶€ë„', 'ë¶ˆì•Œ', 'ë¶•ì•Œ', 'ë¶œì§€', 'ë·©ë”±', 'ë¸…ì‰°', 'ë¸…ì‹ ', 'ë¹™ë¤', 'ë¹™ì‹ ', 'ë¹ ê°€ì‹­ìƒˆ', 'ë¹ ê°€ì”¹ìƒˆ', 'ë¹ êµ¬ë¦¬', 'ë¹ êµ´ì´', 'ë»‘í', 'ë½•ì•Œ', 'ë½€ì§€', 'ë¼ì‹ ', 'ì‚¬ê¹Œì‹œ', 'ìƒë…„', 'ìƒˆêº„', 'ìƒˆë€Œ', 'ìƒˆë¼', 'ìƒ‰ê°¸', 'ìƒ‰ë¼', 'ìƒ‰ìŠ¤', 'ìƒ‰í‚¤', 'ìƒ¤ë°œ', 'ì¨ê¸€', 'ì¨ê¸€ë…„', 'ì„±êµ', 'ì„±í­í–‰', 'ì„¸êº„', 'ì„¸ë¼', 'ì„¹ìŠ¤', 'ì„¹ìŠ¤í•˜ì', 'ì„¹ìŠ¤í•´', 'ì„¹ì“°', 'ì„¹íˆ', 'ìˆ˜ì…”', 'ì‘¤ì…”', 'ì‰ë¼', 'ì‰‘ê°¸', 'ì‰‘ì“°', 'ì‰¬ë°œ', 'ì‰¬ë°©', 'ì‰¬ë°¸ë…„', 'ì‰¬ë²Œ', 'ì‰¬ë¶ˆ', 'ì‰¬ë¶•', 'ì‰¬ë¹¨', 'ì‰¬ì´ë°œ', 'ì‰¬ì´ë°©', 'ì‰¬ì´ë²Œ', 'ì‰¬ì´ë¶ˆ', 'ì‰¬ì´ë¶•', 'ì‰¬ì´ë¹¨', 'ì‰¬ì´íŒ”', 'ì‰¬ì´í„', 'ì‰¬ì´í’€', 'ì‰¬íŒ”', 'ì‰¬í„', 'ì‰¬í’€', 'ì‰½ìŒ”', 'ì‹œëŒ•ì´', 'ì‹œë°œ', 'ì‹œë°œë…„', 'ì‹œë°œë†ˆ', 'ì‹œë°œìƒˆë¼', 'ì‹œë°©ìƒˆ', 'ì‹œë°¸', 'ì‹œë²Œ', 'ì‹œë¶ˆ', 'ì‹œë¶•', 'ì‹œì´ë°œ', 'ì‹œì´ë²Œ', 'ì‹œì´ë¶ˆ', 'ì‹œì´ë¶•', 'ì‹œì´íŒ”', 'ì‹œì´í„', 'ì‹œì´í’€', 'ì‹œíŒìƒˆë¼', 'ì‹œíŒ”', 'ì‹œíŒ”ë„˜', 'ì‹œíŒ”ë…„', 'ì‹œíŒ”ë†ˆ', 'ì‹œíŒ”ìƒˆë¼', 'ì‹œí„', 'ì‹¤í”„', 'ì‹­8', 'ì‹­ë•Œë¼', 'ì‹­ë–¼ë¼', 'ì‹­ë²„ì§€', 'ì‹­ë¶€ë„', 'ì‹­ë¶€ëŸ´', 'ì‹­ìƒˆ', 'ì‹­ì„¸ì´', 'ì‹­ì…°ë¦¬', 'ì‹­ì‰', 'ì‹­ìì„', 'ì‹­ììŠ¥', 'ì‹­ì§€ë„', 'ì‹­ì°½ë…€', 'ì‹­ì°½', 'ì‹­íƒ±', 'ì‹­íƒ±êµ¬ë¦¬', 'ì‹­íƒ±êµ´ì´', 'ì‹­íŒ”ìƒˆë¼', 'ã…†ã…‚', 'ã…†ã…‚ã„¹ã…', 'ã…†ã…‚ã„»', 'ã…†ã…£', 'ìŒë„˜', 'ìŒë…„', 'ìŒë†ˆ', 'ìŒëˆ”', 'ìŒë³´ì§€', 'ìŒ”ë¼', 'ìŒ”ë¦¬', 'ìŒ•ìŠ¤', 'ìŒ•ì“°', 'ì…ë…„', 'ì…ë†ˆ', 'ì…ë‡¬', 'ì…ëŠ ', 'ì“‰ìƒˆ', 'ì“°ë°”ìƒˆë¼', 'ì“°ë¸Œë„ì‰½ì„¸', 'ì”Œë°œ', 'ì”ŒíŒ”', 'ì”¨ê°€ë­ë„˜', 'ì”¨ê°€ë­ë…„', 'ì”¨ê°€ë­ë†ˆ', 'ì”¨ë°œ', 'ì”¨ë°œë…„', 'ì”¨ë°œë¡¬', 'ì”¨ë°œë³‘ì‹ ', 'ì”¨ë°©ìƒˆ', 'ì”¨ë°©ì„¸', 'ì”¨ë°¸', 'ì”¨ë±…ê°€ë¦¬', 'ì”¨ë²Œ', 'ì”¨ë²Œë…„', 'ì”¨ë²Œì‰ì´', 'ì”¨ë¶€ë„', 'ì”¨ë¶€ëŸ´', 'ì”¨ë¶ˆ', 'ì”¨ë¶ˆì•Œ', 'ì”¨ë¶•', 'ì”¨ë¸ŒëŸ´', 'ì”¨ë¸”', 'ì”¨ë¸”ë…„', 'ì”¨ë¸¡ìƒˆë¼', 'ì”¨ë¹¨', 'ì”¨ì´ë°œ', 'ì”¨ì´ë²Œ', 'ì”¨ì´ë¶ˆ', 'ì”¨ì´ë¶•', 'ì”¨ì´íŒ”', 'ì”¨íŒŒë„˜', 'ì”¨íŒìƒˆë¼', 'ì”¨íŒì„¸ë¼', 'ì”¨íŒ”', 'ì”¨í„', 'ì”¨íë„˜', 'ì”¨íë‡¬', 'ì”¨íë³´ì§€', 'ì”¨íìì§€', 'ì”¹ë…„', 'ì”¹ë¬¼', 'ì”¹ë¯¸ë„', 'ì”¹ë²„ì§€', 'ì”¹ë³´ì§€', 'ì”¹ë¶€ë„', 'ì”¹ë¸Œë„', 'ì”¹ë¹µêµ¬', 'ì”¹ë½€ì§€', 'ì”¹ìƒˆ', 'ì”¹ìƒˆë¼', 'ì”¹ì„¸', 'ì”¹ìŒ”ë¼', 'ì”¹ìì„', 'ì”¹ììŠ¥', 'ì”¹ìì§€', 'ì”¹ì§€ë„', 'ì”¹ì°½', 'ì”¹ì°½ë…€', 'ì”¹íƒ±', 'ì”¹íƒ±êµ´ì´', 'ì”¹íƒ±ì´', 'ì”¹íŒ”', 'ì•„ê°€ë¦¬', 'ì• ë¬´', 'ì• ë¯¸', 'ì• ë¯¸ë„', 'ì• ë¯¸ë³´ì§€', 'ì• ë¯¸ì”¨ë±…', 'ì• ë¯¸ìì§€', 'ì• ë¯¸ì¡ë…„', 'ì• ë¯¸ì¢ƒë¬¼', 'ì• ë¹„', 'ì• ì', 'ì–‘ì•„ì¹˜', 'ì–´ë¯¸ê°•ê°„', 'ì–´ë¯¸ë”°ë¨¹ì', 'ì–´ë¯¸ì‘¤ì‹œì', 'ì˜ì', 'ì—„ì°½', 'ì—ë¯¸', 'ì—ë¹„', 'ì—”í”Œë ˆë²„', 'ì— í”Œë ˆë²„', 'ì—¼ë³‘', 'ì—¼ë³‘í• ', 'ì—¼ëµ¹', 'ì—¿ë¨¹ì–´ë¼', 'ì˜¤ë„', 'ì˜¤ë¥´ê°€ì¦˜', 'ì™•ë²„ì§€', 'ì™•ìì§€', 'ì™•ì ì§€', 'ì™•í„¸ë²„ì§€', 'ì™•í„¸ë³´ì§€', 'ì™•í„¸ìì§€', 'ì™•í„¸ì ì§€', 'ìš°ë¯¸ì‘¤ì…”', 'ìš´ë””ë„¤', 'ìš´ì˜ì', 'ìœ ë‘', 'ìœ ë‘ë¹¨ì–´', 'ìœ ë‘í•§ì–´', 'ìœ ë°©', 'ìœ ë°©ë§Œì ¸', 'ìœ ë°©ë¹¨ì•„', 'ìœ ë°©ì£¼ë¬¼ëŸ­', 'ìœ ë°©ìª¼ë¬¼ë”±', 'ìœ ë°©ìª¼ë¬¼ëŸ­', 'ìœ ë°©í•§ì•„', 'ìœ ë°©í•§ì–´', 'ìœ¡ê°‘', 'ì´ê·¸ë‹ˆìŠ¤', 'ì´ë…„', 'ì´í”„ë¦¬íŠ¸', 'ìê¸°í•§ì•„', 'ìì§€', 'ìì§€êµ¬ë…•', 'ìì§€êµ¬ë©', 'ìì§€ê½‚ì•„', 'ìì§€ë„£ì', 'ìì§€ëœ¨ë”', 'ìì§€ëœ¯ì–´', 'ìì§€ë°•ì–´', 'ìì§€ë¹¨ì•„', 'ìì§€ë¹¨ì•„ì¤˜', 'ìì§€ë¹¨ì–´', 'ìì§€ì‘¤ì…”', 'ìì§€ì“°ë ˆê¸°', 'ìì§€ì •ê°œ', 'ìì§€ì§¤ë¼', 'ìì§€í„¸', 'ìì§€í•§ì•„', 'ìì§€í•§ì•„ì¤˜', 'ìì§€í•§ì–´', 'ì‘ì€ë³´ì§€', 'ì ì§€', 'ì ì§€ëš«ì–´', 'ì ì§€ë¬¼ë§ˆì…”', 'ì ì§€í„¸', 'ì ì§“ë¬¼ë§ˆì…”', 'ì¡ë…„', 'ì¡ë†ˆ', 'ì €ë…„', 'ì ë¬¼', 'ì “ê°€íŠ¼', 'ì “ê°€íŠ¼ì‰ì´', 'ì “ê°™ë‚´', 'ì “ê°™ì€', 'ì “ê¹Œ', 'ì “ë‚˜', 'ì “ëƒ„ìƒˆ', 'ì “ëŒ€ê°€ë¦¬', 'ì “ë– ', 'ì “ë§ˆë¬´ë¦¬', 'ì “ë§Œì´', 'ì “ë¬¼', 'ì “ë¬¼ëƒ„ìƒˆ', 'ì “ë°¥', 'ì •ì•¡ë§ˆì…”', 'ì •ì•¡ë¨¹ì–´', 'ì •ì•¡ë°œì‚¬', 'ì •ì•¡ì§œ', 'ì •ì•¡í•§ì•„', 'ì •ìë§ˆì…”', 'ì •ìë¨¹ì–´', 'ì •ìí•§ì•„', 'ì –ê°™ì€', 'ì –ê¹Œ', 'ì –ë°¥', 'ì –íƒ±ì´', 'ì¡°ê°œë„“ì€ë…„', 'ì¡°ê°œë”°ì¡°', 'ì¡°ê°œë§ˆì…”ì¤˜', 'ì¡°ê°œë²Œë ¤ì¡°', 'ì¡°ê°œì†ë¬¼', 'ì¡°ê°œì‘¤ì…”ì¤˜', 'ì¡°ê°œí•§ì•„ì¤˜', 'ì¡°ê¹Œ', 'ì¡°ë˜', 'ì¡±ê°™ë‚´', 'ì¡±ê¹Œ', 'ì¡±ê¹Œë‚´', 'ì¡´ë‚˜', 'ì¡´ë‚˜ê²Œ', 'ì¡´ë‹ˆ', 'ì¡¸ë¼', 'ì¢€ë§ˆë‹ˆ', 'ì¢€ë¬¼', 'ì¢€ì“°ë ˆê¸°', 'ì¢ë¹ ë¼ë¼', 'ì¢ƒê°€íŠ¼ë‡¬', 'ì¢ƒê°„ë…„', 'ì¢ƒê¹Œ', 'ì¢ƒê¹Œë¦¬', 'ì¢ƒê¹Ÿë„¤', 'ì¢ƒëƒ„ìƒˆ', 'ì¢ƒë„˜', 'ì¢ƒëŒ€ê°€ë¦¬', 'ì¢ƒë„', 'ì¢ƒë˜', 'ì¢ƒë§Œì•„', 'ì¢ƒë§Œì´', 'ì¢ƒë§Œí•œê²ƒ', 'ì¢ƒë§Œí•œì‰ì´', 'ì¢ƒë¬¼', 'ì¢ƒë¬¼ëƒ„ìƒˆ', 'ì¢ƒë³´ì§€', 'ì¢ƒë¶€ë„', 'ì¢ƒë¹ êµ¬ë¦¬', 'ì¢ƒë¹ ë„¤', 'ì¢ƒë¹ ë¼ë¼', 'ì¢ƒí„¸', 'ì¢†ê°™ì€ë†ˆ', 'ì¢†ê°™ì€ìƒˆë¼', 'ì¢†ê¹Œ', 'ì¢†ê¹Œë¼', 'ì¢†ë‚˜', 'ì¢†ë…„', 'ì¢†ë„', 'ì¢†ë§Œì•„', 'ì¢†ë§Œí•œë…„', 'ì¢†ë§Œí•œë†ˆ', 'ì¢†ë§Œí•œìƒˆë¼', 'ì¢†ë¨¹ì–´', 'ì¢†ë¬¼', 'ì¢†ë°¥', 'ì¢†ë¹¨ì•„', 'ì¢†ìƒˆë¼', 'ì¢†í„¸', 'ì¢‹ë§Œí•œê²ƒ', 'ì£¼ê¸€ë…„', 'ì£¼ê¸¸ë…„', 'ì¥ë„', 'ì§€ë„', 'ì§€ë¼', 'ì§€ëŸ´', 'ì§€ë¢€', 'ìª¼ê¹ŒíŠ¼', 'ìª¼ë‹¤', 'ìª¼ë‹¤ìƒˆë¼', 'ì°Œë„', 'ì°Œì§ˆì´', 'ì°½ë‚¨', 'ì°½ë…€', 'ì°½ë…€ë²„ì§€', 'ì°½ë…„', 'ì²˜ë¨¹ê³ ', 'ì²˜ë¨¹ì„', 'ì³ë¨¹ê³ ', 'ì³ì‘¤ì…”ë°•ì–´', 'ì´Œì”¨ë¸Œë¼ë¦¬', 'ì´Œì”¨ë¸Œë‘ì´', 'ì´Œì”¨ë¸Œë­ì´', 'í¬ë¦¬í† ë¦¬ìŠ¤', 'í°ë³´ì§€', 'í´ë¦¬í† ë¦¬ìŠ¤', 'íŠ¸ëœìŠ¤ì  ë”', 'í˜ë‹ˆìŠ¤', 'í•­ë¬¸ìˆ˜ì…”', 'í•­ë¬¸ì‘¤ì…”', 'í—ˆë¥', 'í—ˆë²„ë¦¬ë…„', 'í—ˆë²Œë…„', 'í—ˆë²Œë³´ì§€', 'í—ˆë²Œìì‹', 'í—ˆë²Œìì§€', 'í—ˆì ‘', 'í—ˆì š', 'í—ˆì¡‰', 'í—ˆì¢', 'í—ë ë³´ì§€', 'í˜€ë¡œë³´ì§€í•§ê¸°', 'í˜¸ëƒ¥ë…„', 'í˜¸ë¡œ', 'í˜¸ë¡œìƒˆë¼', 'í˜¸ë¡œììŠ¥', 'í˜¸ë¡œìì‹', 'í˜¸ë¡œì§œì‹', 'í˜¸ë£¨ììŠ¥', 'í˜¸ëª¨', 'í˜¸ì¡‰', 'í˜¸ì¢', 'í›„ë¼ëœë„˜', 'í›„ì¥', 'í›„ì¥ê½‚ì•„', 'í›„ì¥ëš«ì–´', 'íì ‘', 'íì š', 'íì¡‰', 'bitch', 'fuck', "fuckyou", "nflavor", "penis", "pennis", "pussy", "sex", "ì‹œ8", "ì‹œ2ë°œ", "ì‹œ1ë°œ", "ì”¨ ë°œ", "ì‹œ ë°œ", "/\  ã…£ ë°œ", "ë³‘ì‹œì‹ ë°œ", "ã…—", "ì¥ì• ", "ì¢‡ê°€", "ì¢‡ê¹Œ", "ì‹œ.       ë°œ", "ì”¨ë¶¤", "ì’¸ë²Œ", "ì’¸ë°œ", "ì”¨ ë¹Œ", "ì“°ë ˆê¸° ã……ã„²", "ì“°ë˜ê¸° ë…„", "ì“°ë˜ê¸° ã……ã„²", "ì“°ë ˆê¸° ë…„", "ë‚˜ê°€ ë’¤ì ¸", "ã……ã„²", "ã„´ã„±ã…", "ëŠê¸ˆë§ˆ", ]  # ì—¬ê¸°ì— ìœ„ë°˜ ê·œì¹™ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŒ

@bot.event
async def on_ready():
    print(f"{bot.user}ë¡œ ë¡œê·¸ì¸í–ˆìŠµë‹ˆë‹¤!")

# ê·œì¹™ ìœ„ë°˜ ê°ì§€ í•¨ìˆ˜
def contains_bad_words(message):
    for word in BAD_WORDS:
        if re.search(r"\b" + re.escape(word) + r"\b", message.content, re.IGNORECASE):
            return True
    return False

@bot.event
async def on_message(message):
    if message.author.bot:
        return

    # DMì—ì„œ ê³µì§€ ëª…ë ¹ì–´ ì²˜ë¦¬
    if isinstance(message.channel, discord.DMChannel):
        if message.content.startswith("!ê³µì§€"):
            try:
                parts = message.content.split(" ", 2)
                if len(parts) < 3:
                    await message.channel.send("ì‚¬ìš©ë²•: !ê³µì§€ {ì±„ë„ì´ë¦„} {ë©”ì„¸ì§€}")
                    return

                channel_name = parts[1]
                msg = parts[2]

                guild = bot.get_guild(1330541603542269972)  # ì„œë²„ ID ì…ë ¥
                channel = discord.utils.get(guild.text_channels, name=channel_name)
                
                if channel is None:
                    await message.channel.send(f"ì±„ë„ '{channel_name}'ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                    return

                await channel.send(msg)
                await message.channel.send(f"'{channel_name}' ì±„ë„ì— ê³µì§€ê°€ ì„±ê³µì ìœ¼ë¡œ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.")
            except Exception as e:
                await message.channel.send(f"ì—ëŸ¬ ë°œìƒ: {str(e)}")
        else:
            await message.channel.send("ì´ ì±„ë„ì—ì„œëŠ” ëª…ë ¹ì–´ë¥¼ ë°›ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. !ê³µì§€ {ì±„ë„ì´ë¦„} {ë©”ì„¸ì§€} í˜•ì‹ìœ¼ë¡œ ë³´ë‚´ì£¼ì„¸ìš”.")
        return

    # ğŸ”¹ ê²½ê³  ì´ˆê¸°í™” ëª…ë ¹ì–´ (!ì´ˆê¸°í™” @ì‚¬ìš©ì)
    if message.content.startswith("!ì´ˆê¸°í™”"):
        if message.mentions:
            user = message.mentions[0]
            user_id = str(user.id)

            if user_id in warnings:
                warnings[user_id] = 0
                save_warnings(warnings)  # JSON ì €ì¥
                await message.channel.send(f"âœ… {user.mention}ë‹˜ì˜ ê²½ê³  ê¸°ë¡ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.")
            else:
                await message.channel.send(f"âš ï¸ {user.mention}ë‹˜ì˜ ê²½ê³  ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.")
        else:
            await message.channel.send("ì‚¬ìš©ë²•: `!ì´ˆê¸°í™” @ì‚¬ìš©ì`")
        return

    # ğŸ”¹ ìš•ì„¤ ê°ì§€ ë° ê²½ê³  ì‹œìŠ¤í…œ
    if any(word in message.content.lower() for word in BAD_WORDS):
        user = message.author
        user_id = str(user.id)

        warnings[user_id] = warnings.get(user_id, 0) + 1  # ê²½ê³  ì¦ê°€
        save_warnings(warnings)  # JSON ì €ì¥

        # ğŸ”¹ ê´€ë¦¬ìì—ê²Œ DMìœ¼ë¡œ ê²½ê³  ì‹ ê³  ì „ì†¡
        report_message = (
            f"ğŸš¨ **ì‹ ê³  ì ‘ìˆ˜ë¨** ğŸš¨\n\n"
            f"ğŸ‘¤ **ì‚¬ìš©ì**: {user} ({user.id})\n"
            f"âš ï¸ **ê·œì¹™ ìœ„ë°˜ ë‚´ìš©**: {message.content}\n"
            f"ğŸ“Š **ëˆ„ì  ìœ„ë°˜ íšŸìˆ˜**: {warnings[user_id]}íšŒ"
        )

        admin = await bot.fetch_user(admin_id)
        if admin:
            await admin.send(report_message)

        # ğŸ”¹ ê²½ê³  ì´ˆê³¼ ì‹œ 1ì£¼ì¼ íƒ€ì„ì•„ì›ƒ
        if warnings[user_id] >= WARNING_LIMIT:
            try:
                timeout_until = discord.utils.utcnow() + timedelta(seconds=MUTE_DURATION)
                await message.channel.send(
                    f"â›” {user.mention}, ê²½ê³  {WARNING_LIMIT}íšŒ ì´ˆê³¼ë¡œ **1ì£¼ì¼ íƒ€ì„ì•„ì›ƒ** ì²˜ë¦¬ë©ë‹ˆë‹¤."
                )
                await user.timeout(timeout_until, reason="ìš•ì„¤ ëˆ„ì  ê²½ê³  ì´ˆê³¼")
                warnings[user_id] = 0  # ê²½ê³  ì´ˆê¸°í™”
                save_warnings(warnings)  # JSON ì €ì¥
            except Exception as e:
                print(f"âŒ íƒ€ì„ì•„ì›ƒ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")
        else:
            await message.channel.send(
                f"âš ï¸ {user.mention}, ìš•ì„¤ì€ ê¸ˆì§€ë˜ì–´ ìˆìŠµë‹ˆë‹¤. í•œë²ˆ ë” ìš•ì„ í•œë‹¤ë©´ ë®¤íŠ¸(1ì£¼ì¼) ì²˜ë¦¬í•˜ê² ìŠµë‹ˆë‹¤. í˜„ì¬ ê²½ê³  íšŸìˆ˜: {warnings[user_id]} / {WARNING_LIMIT}."
            )

        # ğŸ”¹ ë©”ì‹œì§€ ì‚­ì œ
        try:
            await message.delete()
        except Exception as e:
            print(f"âŒ ë©”ì‹œì§€ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {e}")

    await bot.process_commands(message)

    # FFmpeg ë° yt-dlp ì˜µì…˜ ì„¤ì •
FFMPEG_OPTIONS = {
    'before_options': '-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5',
    'options': '-vn'
}

async def fetch_valorant_update():
    async with aiohttp.ClientSession() as session:
        async with session.get(VALORANT_PATCH_URL) as response:
            html = await response.text()
            soup = BeautifulSoup(html, 'html.parser')
            latest_patch = soup.find('a', class_='NewsCard__CardLink')
            if latest_patch:
                title = latest_patch.find('h3').text.strip()
                link = 'https://playvalorant.com' + latest_patch['href']
                return f'ğŸ”´ **Valorant ì—…ë°ì´íŠ¸**: {title}\nğŸ”— {link}'
            return None

async def fetch_fisch_update():
    async with aiohttp.ClientSession() as session:
        async with session.get(FISCH_GAME_URL) as response:
            html = await response.text()
            soup = BeautifulSoup(html, 'html.parser')
            update_section = soup.find('div', class_='game-update-section')  # Replace with actual class
            if update_section:
                title = update_section.find('h3').text.strip()
                return f'ğŸ”µ **Roblox - Fisch ì—…ë°ì´íŠ¸**: {title}'
            return None

@tasks.loop(minutes=1)  # Check every 30 minutes
async def check_updates():
    channel = bot.get_channel(1330541603542269979)  # Replace with your channel ID
    if channel:
        valorant_update = await fetch_valorant_update()
        fisch_update = await fetch_fisch_update()
        
        if valorant_update:
            await channel.send(valorant_update)
        if fisch_update:
            await channel.send(fisch_update)

# FFmpeg ì‹¤í–‰ íŒŒì¼ ê²½ë¡œ
FFMPEG_EXECUTABLE = "C:/ffmpeg/bin/ffmpeg.exe"


YDL_OPTIONS = {'format': 'bestaudio', 'noplaylist': 'True'}
DEFAULT_VOLUME = 0.5  # ê¸°ë³¸ ë³¼ë¥¨ ì„¤ì • (50%)

# ëŒ€ê¸°ì—´ ì´ˆê¸°í™”
song_queue = []

# ì¸ê¸° í”Œë ˆì´ë¦¬ìŠ¤íŠ¸ ìƒ˜í”Œ ëª©ë¡
popular_playlists = [
    "https://www.youtube.com/watch?v=K4DyBUG242c&list=PLDcnymzs18LVXfO_x0Ei0R24qDbVtyy66",
    "https://www.youtube.com/watch?v=ScMzIvxBSi4&list=PLFgquLnL59alGJcdc0BEZJb2p7Igk83fk",
    "https://www.youtube.com/watch?v=JGwWNGJdvx8&list=PLMC9KNkIncKtPzgY-5rmhvj7fax8fdxoj"
]

# ìˆ˜ëŠ¥ê¸ˆì§€ê³¡ ìƒ˜í”Œ ëª©ë¡
forbidden_songs = [
    "https://www.youtube.com/watch?v=9bZkp7q19f0",  # ì˜ˆ: ê°•ë‚¨ìŠ¤íƒ€ì¼
    "https://www.youtube.com/watch?v=60ItHLz5WEA",  # ì˜ˆ: Alone
    "https://www.youtube.com/watch?v=3AtDnEC4zak"   # ì˜ˆ: Shape of You
]

# ë©”ë“œë¬´ë¹„ ë¸Œê¸ˆ ìƒ˜í”Œ ëª©ë¡
bgm_songs = [
    "https://www.youtube.com/watch?v=2Vv-BfVoq4g",  # Perfect
    "https://www.youtube.com/watch?v=fJ9rUzIMcZQ",  # Bohemian Rhapsody
    "https://www.youtube.com/watch?v=6Ejga4kJUts"   # Zombie
]

# ë´‡ ì¤€ë¹„ ìƒíƒœ
@bot.event
async def on_ready():
    print(f"ë´‡ì´ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤: {bot.user.name}")
    logging.info(f"Logged in as {bot.user.name}")

# ë…¸ë˜ ì¬ìƒ í•¨ìˆ˜
def play_next(vc):
    if song_queue:
        next_song = song_queue.pop(0)
        vc.play(discord.PCMVolumeTransformer(next_song['audio_source'], volume=DEFAULT_VOLUME), after=lambda e: play_next(vc))

class MusicControls(discord.ui.View):
    def __init__(self, ctx):
        super().__init__(timeout=None)
        self.ctx = ctx

    @discord.ui.button(label="â¸ï¸ ì¼ì‹œì •ì§€", style=discord.ButtonStyle.secondary)
    async def pause(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.ctx.voice_client and self.ctx.voice_client.is_playing():
            self.ctx.voice_client.pause()
            await interaction.response.send_message("â¸ï¸ ìŒì•…ì´ ì¼ì‹œì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.", ephemeral=True)

    @discord.ui.button(label="â–¶ï¸ ì¬ìƒ", style=discord.ButtonStyle.secondary)
    async def resume(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.ctx.voice_client and self.ctx.voice_client.is_paused():
            self.ctx.voice_client.resume()
            await interaction.response.send_message("â–¶ï¸ ìŒì•…ì´ ì¬ìƒë˜ì—ˆìŠµë‹ˆë‹¤.", ephemeral=True)

    @discord.ui.button(label="â­ï¸ ê±´ë„ˆë›°ê¸°", style=discord.ButtonStyle.primary)
    async def skip(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.ctx.voice_client and self.ctx.voice_client.is_playing():
            self.ctx.voice_client.stop()
            await interaction.response.send_message("â­ï¸ ìŒì•…ì„ ê±´ë„ˆë›°ì—ˆìŠµë‹ˆë‹¤.", ephemeral=True)

    @discord.ui.button(label="ğŸ›‘ ì •ì§€", style=discord.ButtonStyle.danger)
    async def stop(self, interaction: discord.Interaction, button: discord.ui.Button):
        if self.ctx.voice_client:
            await self.ctx.voice_client.disconnect()
            await interaction.response.send_message("ğŸ›‘ ìŒì•…ì„ ì •ì§€í•˜ê³  ìŒì„± ì±„ë„ì—ì„œ ë‚˜ì™”ìŠµë‹ˆë‹¤.", ephemeral=True)

    @discord.ui.button(label="ğŸ¶ ì¸ê¸° í”Œë ˆì´ë¦¬ìŠ¤íŠ¸", style=discord.ButtonStyle.success)
    async def popular_playlist(self, interaction: discord.Interaction, button: discord.ui.Button):
        playlist_url = random.choice(popular_playlists)
        await self.play_from_url(interaction, playlist_url)

    @discord.ui.button(label="ğŸµ ìˆ˜ëŠ¥ê¸ˆì§€ê³¡", style=discord.ButtonStyle.success)
    async def forbidden_song(self, interaction: discord.Interaction, button: discord.ui.Button):
        song_url = random.choice(forbidden_songs)
        await self.play_from_url(interaction, song_url)

    @discord.ui.button(label="ğŸ¥ ë©”ë“œë¬´ë¹„ ë¸Œê¸ˆ", style=discord.ButtonStyle.success)
    async def bgm_song(self, interaction: discord.Interaction, button: discord.ui.Button):
        song_url = random.choice(bgm_songs)
        await self.play_from_url(interaction, song_url)

    @discord.ui.button(label="ğŸ” ë…¸ë˜ ê²€ìƒ‰", style=discord.ButtonStyle.primary)
    async def search_song(self, interaction: discord.Interaction, button: discord.ui.Button):
        await interaction.response.send_message("ê²€ìƒ‰í•  ë…¸ë˜ ì œëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”:", ephemeral=True)

        def check(msg):
            return msg.author == interaction.user and msg.channel == interaction.channel

        try:
            msg = await bot.wait_for("message", check=check, timeout=30)
            search = msg.content

            with youtube_dl.YoutubeDL(YDL_OPTIONS) as ydl:
                try:
                    if "http" not in search:
                        search = f"ytsearch:{search}"

                    info = ydl.extract_info(search, download=False)
                    if "entries" in info:
                        info = info["entries"][0]

                    url2 = info['url']
                    title = info['title']

                    audio_source = discord.FFmpegPCMAudio(executable=FFMPEG_EXECUTABLE, source=url2, **FFMPEG_OPTIONS)

                    vc = self.ctx.voice_client
                    if not vc:
                        if self.ctx.author.voice:
                            await self.ctx.author.voice.channel.connect()
                            vc = self.ctx.voice_client
                        else:
                            await interaction.followup.send("ë¨¼ì € ìŒì„± ì±„ë„ì— ë“¤ì–´ê°€ì•¼ í•©ë‹ˆë‹¤!", ephemeral=True)
                            return

                    if not vc.is_playing():
                        vc.play(discord.PCMVolumeTransformer(audio_source, volume=DEFAULT_VOLUME), after=lambda e: play_next(vc))
                        await interaction.followup.send(f"ğŸµ ì§€ê¸ˆ ì¬ìƒ ì¤‘: **{title}**")
                    else:
                        song_queue.append({'title': title, 'audio_source': audio_source})
                        await interaction.followup.send(f"ğŸ“‹ ëŒ€ê¸°ì—´ì— ì¶”ê°€ë¨: **{title}**")
                except Exception as e:
                    await interaction.followup.send(f"âš ï¸ ë…¸ë˜ë¥¼ ì¬ìƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}")
        except asyncio.TimeoutError:
            await interaction.followup.send("â³ ì‹œê°„ ì´ˆê³¼! ê²€ìƒ‰ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.", ephemeral=True)

    async def play_from_url(self, interaction, url):
        ctx = self.ctx
        vc = ctx.voice_client

        if not vc:
            if ctx.author.voice:
                await ctx.author.voice.channel.connect()
                vc = ctx.voice_client
            else:
                await interaction.response.send_message("ë¨¼ì € ìŒì„± ì±„ë„ì— ë“¤ì–´ê°€ì•¼ í•©ë‹ˆë‹¤!", ephemeral=True)
                return

        with youtube_dl.YoutubeDL(YDL_OPTIONS) as ydl:
            try:
                info = ydl.extract_info(url, download=False)
                if "entries" in info:
                    info = info["entries"][0]

                url2 = info['url']
                title = info['title']

                audio_source = discord.FFmpegPCMAudio(executable=FFMPEG_EXECUTABLE, source=url2, **FFMPEG_OPTIONS)

                if not vc.is_playing():
                    vc.play(discord.PCMVolumeTransformer(audio_source, volume=DEFAULT_VOLUME), after=lambda e: play_next(vc))
                    await interaction.response.send_message(f"ğŸµ ì§€ê¸ˆ ì¬ìƒ ì¤‘: **{title}**")
                else:
                    song_queue.append({'title': title, 'audio_source': audio_source})
                    await interaction.response.send_message(f"ğŸ“‹ ëŒ€ê¸°ì—´ì— ì¶”ê°€ë¨: **{title}**")
            except Exception as e:
                await interaction.response.send_message(f"âš ï¸ ìŒì•…ì„ ì¬ìƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}")

                # !ì¬ìƒ ëª…ë ¹ì–´
@bot.command(name="ì¬ìƒ")
async def play(ctx, *, search: str):
    if not ctx.voice_client:
        if ctx.author.voice:
            await ctx.author.voice.channel.connect()
        else:
            await ctx.send("ë¨¼ì € ìŒì„± ì±„ë„ì— ë“¤ì–´ê°€ì•¼ í•©ë‹ˆë‹¤!")
            return

    vc = ctx.voice_client

    with youtube_dl.YoutubeDL(YDL_OPTIONS) as ydl:
        try:
            if "http" not in search:
                search = f"ytsearch:{search}"

            info = ydl.extract_info(search, download=False)
            if "entries" in info:
                info = info["entries"][0]

            url2 = info['url']
            title = info['title']

            audio_source = discord.FFmpegPCMAudio(executable=FFMPEG_EXECUTABLE, source=url2, **FFMPEG_OPTIONS)

            if not vc.is_playing():
                vc.play(discord.PCMVolumeTransformer(audio_source, volume=DEFAULT_VOLUME), after=lambda e: play_next(vc))
                await ctx.send(f"ğŸµ ì§€ê¸ˆ ì¬ìƒ ì¤‘: **{title}**", view=MusicControls(ctx))
            else:
                song_queue.append({'title': title, 'audio_source': audio_source})
                await ctx.send(f"ğŸ“‹ ëŒ€ê¸°ì—´ì— ì¶”ê°€ë¨: **{title}**")
        except Exception as e:
            await ctx.send(f"âš ï¸ ìŒì•…ì„ ì¬ìƒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}")

# !ëŒ€ê¸°ì—´ ëª…ë ¹ì–´
@bot.command(name="ëŒ€ê¸°ì—´")
async def queue(ctx):
    if song_queue:
        queue_list = '\n'.join([f"{idx + 1}. {song['title']}" for idx, song in enumerate(song_queue)])
        await ctx.send(f"ğŸ“‹ ëŒ€ê¸°ì—´ ëª©ë¡:\n{queue_list}")
    else:
        await ctx.send("ğŸ“‹ ëŒ€ê¸°ì—´ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.")

# !ë³¼ë¥¨ ëª…ë ¹ì–´
@bot.command(name="ë³¼ë¥¨")
async def volume(ctx, volume: int):
    if ctx.voice_client and ctx.voice_client.source:
        if 0 <= volume <= 100:
            ctx.voice_client.source.volume = volume / 100
            await ctx.send(f"ğŸ”Š ë³¼ë¥¨ì´ **{volume}%**ë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤!")
        else:
            await ctx.send("âš ï¸ ë³¼ë¥¨ì€ 0ì—ì„œ 100 ì‚¬ì´ë¡œ ì„¤ì •í•´ì•¼ í•©ë‹ˆë‹¤.")
    else:
        await ctx.send("âš ï¸ í˜„ì¬ ì¬ìƒ ì¤‘ì¸ ìŒì•…ì´ ì—†ìŠµë‹ˆë‹¤.")

# !ì¤‘ì§€ ëª…ë ¹ì–´
@bot.command(name="ì¤‘ì§€")
async def stop(ctx):
    if ctx.voice_client:
        await ctx.voice_client.disconnect()
        await ctx.send("ğŸ›‘ ìŒì„± ì±„ë„ì—ì„œ ë‚˜ì™”ìŠµë‹ˆë‹¤!")
    else:
        await ctx.send("âš ï¸ ë´‡ì´ ìŒì„± ì±„ë„ì— ìˆì§€ ì•ŠìŠµë‹ˆë‹¤.")

# ì¬ì—°ê²° ë¡œì§
@bot.event
async def on_voice_state_update(member, before, after):
    if member.id == bot.user.id:
        if before.channel and not after.channel:
            print("ë´‡ì´ ìŒì„± ì±„ë„ì—ì„œ ë‚˜ê°”ìŠµë‹ˆë‹¤. ì¬ì—°ê²° ì‹œë„ ì¤‘...")
            await asyncio.sleep(1)
            try:
                if before.channel:
                    await before.channel.connect()
                    print("ì¬ì—°ê²° ì„±ê³µ!")
            except Exception as e:
                print(f"ì¬ì—°ê²° ì‹¤íŒ¨: {e}")

# ì˜¤ë¥˜ í•¸ë“¤ë§
@bot.event
async def on_error(event, *args, **kwargs):
    logging.error(f"ì˜¤ë¥˜ ë°œìƒ: {event}", exc_info=True)

@bot.command()
async def íŒ€ëœë¤(ctx, *users: str):
    if len(users) < 2:
        await ctx.send("ë‘ ëª… ì´ìƒì˜ ìœ ì €ë¥¼ ì§€ì •í•´ì•¼ í•©ë‹ˆë‹¤.")
        return

    # ì‰¼í‘œ ì œê±° ë° ìœ ì € ë©˜ì…˜ ì²˜ë¦¬
    users = [user.strip("<@!>,") for user in users]  # ì‰¼í‘œ ë° ë¶ˆí•„ìš”í•œ ê³µë°± ì œê±°
    members = []
    for user in users:
        member = ctx.guild.get_member(int(user))
        if member:
            members.append(member)
        else:
            await ctx.send(f"ìœ íš¨í•˜ì§€ ì•Šì€ ìœ ì € ID: {user}")
            return

    random.shuffle(members)
    mid = len(members) // 2
    team_a = members[:mid]
    team_b = members[mid:]

    team_a_mentions = [user.mention for user in team_a]
    team_b_mentions = [user.mention for user in team_b]
    await ctx.send(f"**AíŒ€:** {', '.join(team_a_mentions)}\n**BíŒ€:** {', '.join(team_b_mentions)}")

# ë¡œê·¸ ì±„ë„ ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ” í•¨ìˆ˜
def save_log_channel(channel_id):
    with open(LOG_FILE, "w") as f:
        json.dump({"log_channel": channel_id}, f)

# ë¡œê·¸ ì±„ë„ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” í•¨ìˆ˜
def load_log_channel():
    if os.path.exists(LOG_FILE):
        with open(LOG_FILE, "r") as f:
            data = json.load(f)
            return data.get("log_channel")
    return None

# ğŸ“Œ íŒŒì¼ì—ì„œ ë¡œê·¸ ì±„ë„ ë¶ˆëŸ¬ì˜¤ê¸°
def load_log_channels():
    if os.path.exists(LOG_FILE):
        with open(LOG_FILE, "r", encoding="utf-8") as f:
            try:
                data = json.load(f)
                if isinstance(data, list):  # ë°ì´í„°ê°€ ë¦¬ìŠ¤íŠ¸ì¸ì§€ í™•ì¸
                    return data
                else:
                    return []  # ë§Œì•½ ë”•ì…”ë„ˆë¦¬ í˜•íƒœë¼ë©´ ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
            except json.JSONDecodeError:
                return []  # íŒŒì¼ì´ ë¹„ì–´ ìˆê±°ë‚˜ ì˜ëª»ëœ í˜•ì‹ì¼ ê²½ìš° ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜
    return []  # íŒŒì¼ì´ ì—†ì„ ê²½ìš° ë¹ˆ ë¦¬ìŠ¤íŠ¸ ë°˜í™˜

# ğŸ“Œ ë¡œê·¸ ì±„ë„ì„ íŒŒì¼ì— ì €ì¥
def save_log_channels():
    with open(LOG_FILE, "w", encoding="utf-8") as f:
        json.dump(log_channels, f)

log_channels = load_log_channels()  # ì‹œì‘í•  ë•Œ ì €ì¥ëœ ë¡œê·¸ ì±„ë„ ë¶ˆëŸ¬ì˜¤ê¸°

# ğŸ”„ ë´‡ì´ ì‹¤í–‰ë  ë•Œ ì„¤ì •ëœ ë¡œê·¸ ì±„ë„ í™•ì¸
@bot.event
async def on_ready():
    print(f"âœ… ë´‡ì´ ì‹¤í–‰ë˜ì—ˆìŠµë‹ˆë‹¤. (ë“±ë¡ëœ ë¡œê·¸ ì±„ë„ ê°œìˆ˜: {len(log_channels)})")

# ğŸ“Œ ë¡œê·¸ ì±„ë„ ì¶”ê°€
@bot.command()
async def ë¡œê·¸ì„¤ì •(ctx, channel: discord.TextChannel):
    if channel.id not in log_channels:
        log_channels.append(channel.id)  # ë¡œê·¸ ì±„ë„ ì¶”ê°€
        save_log_channels()  # íŒŒì¼ì— ì €ì¥
        await ctx.send(f"âœ… ë¡œê·¸ ì±„ë„ ì¶”ê°€: {channel.mention}")
    else:
        await ctx.send("âš ï¸ ì´ ì±„ë„ì€ ì´ë¯¸ ë¡œê·¸ ì±„ë„ì…ë‹ˆë‹¤.")

# ğŸ“Œ ë¡œê·¸ ì±„ë„ ì‚­ì œ
@bot.command()
async def ë¡œê·¸ì‚­ì œ(ctx, channel: discord.TextChannel):
    if channel.id in log_channels:
        log_channels.remove(channel.id)  # ë¡œê·¸ ì±„ë„ ì œê±°
        save_log_channels()  # íŒŒì¼ì— ì €ì¥
        await ctx.send(f"âŒ ë¡œê·¸ ì±„ë„ ì‚­ì œ: {channel.mention}")
    else:
        await ctx.send("âš ï¸ ì´ ì±„ë„ì€ ë¡œê·¸ ì±„ë„ì´ ì•„ë‹™ë‹ˆë‹¤.")

# ğŸ“Œ ì—¬ëŸ¬ ì±„ë„ì— ë¡œê·¸ ë©”ì‹œì§€ ì „ì†¡
async def send_log(message):
    for channel_id in log_channels:
        channel = bot.get_channel(channel_id)
        if channel:
            await channel.send(message)

# ğŸ“Œ ë©”ì‹œì§€ ì‚­ì œ ë¡œê·¸
@bot.event
async def on_message_delete(message):
    await send_log(f"ğŸ—‘ï¸ ë©”ì‹œì§€ ì‚­ì œ: {message.author} ({message.content})")

# ğŸ“Œ ë©¤ë²„ ì…ì¥ ë¡œê·¸
@bot.event
async def on_member_join(member):
    await send_log(f"ğŸ‘‹ {member}ê°€ ì„œë²„ì— ì…ì¥í–ˆìŠµë‹ˆë‹¤.")

# ğŸ“Œ ë©¤ë²„ í‡´ì¥ ë¡œê·¸
@bot.event
async def on_member_remove(member):
    await send_log(f"ğŸšª {member}ê°€ ì„œë²„ë¥¼ ë– ë‚¬ìŠµë‹ˆë‹¤.")

# ğŸ“Œ ì—­í•  ë³€ê²½ ë¡œê·¸
@bot.event
async def on_member_update(before, after):
    if before.roles != after.roles:
        await send_log(f"ğŸ”„ {before}ì˜ ì—­í• ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤: {before.roles} â†’ {after.roles}")

# ğŸ“Œ ìµœê·¼ 10ê°œ ë¡œê·¸ í™•ì¸
@bot.command()
async def ë¡œê·¸ë³´ê¸°(ctx):
    if log_channels:
        logs = []
        for channel_id in log_channels:
            channel = bot.get_channel(channel_id)
            if channel:
                async for msg in channel.history(limit=10):
                    logs.append(f"[{channel.name}] {msg.content}")
        if logs:
            await ctx.send("\n".join(logs[-10:]))
        else:
            await ctx.send("ğŸ“­ ë¡œê·¸ê°€ ì—†ìŠµë‹ˆë‹¤.")
    else:
        await ctx.send("âš ï¸ ë¡œê·¸ ì±„ë„ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

        # ì„œë²„ ì´ë¦„ ë³€ê²½ ë¡œê·¸
@bot.event
async def on_guild_update(before, after):
    if before.name != after.name:
        await send_log(f"ğŸ“ ì„œë²„ ì´ë¦„ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤: {before.name} â†’ {after.name}")

# ì„œë²„ ì•„ì´ì½˜ ë³€ê²½ ë¡œê·¸
@bot.event
async def on_guild_update(before, after):
    if before.icon != after.icon:
        await send_log(f"ğŸ–¼ï¸ ì„œë²„ ì•„ì´ì½˜ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.")

# ì°¨ë‹¨ ë¡œê·¸
@bot.command()
async def ì°¨ë‹¨(ctx, member: discord.Member, reason: str):
    # ì°¨ë‹¨ ë¡œì§
    await send_log(f"â›” {member}ê°€ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. ì‚¬ìœ : {reason}")
    await ctx.send(f"{member}ê°€ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.")

@bot.command()
async def íˆ¬í‘œ(ctx, question: str, *choices: str):
    # ì„ íƒì§€ê°€ 2ê°œ ì´ìƒì´ì–´ì•¼ í•œë‹¤ëŠ” ì¡°ê±´ ì¶”ê°€
    if len(choices) < 2:
        await ctx.send("ìµœì†Œ 2ê°œì˜ ì„ íƒì§€ê°€ í•„ìš”í•©ë‹ˆë‹¤.")
        return

    # ì§ˆë¬¸ê³¼ ì„ íƒì§€ í…ìŠ¤íŠ¸ ìƒì„±
    embed = discord.Embed(title=question, description="ë‹¤ìŒ ì¤‘ í•˜ë‚˜ë¥¼ ì„ íƒí•˜ì„¸ìš”.", color=discord.Color.blue())

    # ê° ì„ íƒì§€ì— ëŒ€í•´ ë²ˆí˜¸ ì§€ì •
    for i, choice in enumerate(choices):
        embed.add_field(name=f"ì„ íƒì§€ {i+1}: {choice}", value=f"ğŸ¤” {choice}", inline=False)

    # ë©”ì‹œì§€ë¥¼ ë³´ëƒ„
    message = await ctx.send(embed=embed)

    # ê° ì„ íƒì§€ì— ëŒ€í•´ ë°˜ì‘(ì´ëª¨ì§€) ì¶”ê°€
    emojis = ["1ï¸âƒ£", "2ï¸âƒ£", "3ï¸âƒ£", "4ï¸âƒ£", "5ï¸âƒ£", "6ï¸âƒ£"]  # ìµœëŒ€ 6ê°œì˜ ì„ íƒì§€
    for i in range(len(choices)):
        await message.add_reaction(emojis[i])

    # ë°˜ì‘ì„ ëˆ„ë¥¸ ì‚¬ìš©ìë“¤ì„ ê¸°ë¡í•˜ëŠ” ë°©ë²•ì„ ì¶”ê°€í•˜ë ¤ë©´, ì¶”ê°€ì ì¸ ë¡œì§ í•„ìš”

# í™˜ê²½ë³€ìˆ˜ì—ì„œ í† í° ê°€ì ¸ì˜¤ê¸°
TOKEN = os.getenv("TOKEN")  # í™˜ê²½ë³€ìˆ˜ ì´ë¦„ í™•ì¸!

if TOKEN is None:
    raise ValueError("ğŸš¨ í™˜ê²½ë³€ìˆ˜ TOKENì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤!")

# âŒ ì˜ëª»ëœ ì½”ë“œ: bot.run("TOKEN")  (ë¬¸ìì—´ "TOKEN"ì„ ì…ë ¥í•˜ê³  ìˆìŒ)
# âœ… ì˜¬ë°”ë¥¸ ì½”ë“œ:
bot.run(TOKEN)
